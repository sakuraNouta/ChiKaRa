
# 重写与重载
1. 重写(Override)
为了满足里氏替换原则，重写有两个限制：
    *  子类方法的访问权限必须大于等于父类方法
    *  子类方法的返回类型必须是父类方法返回类型或为其子类型
2. 重载(Overload)
存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

# 抽象类与接口





抽象类和普通类的最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类
抽象方法一定位于抽象类中
接口可以看出是一个完全抽象的类，在java8后，接口也可以拥有默认的方法实现

# java关键字
true,false,null是保留字
## super关键字
* 访问父类的构造函数:可以使用super()函数访问父类的构造函数，从而委托父类完成一些初始化的工作
* 访问父类的成员:如果子类重写了父类中的某个方法的实现，可以通过使用super关键字来引用父类的方法实现
## transient
seriazation序列化，以有序的或序列化的比特的形式持久化java对象
用transient关键字标记的成员变量不参与序列化过程。

# LinkedList与ArrayList的比较
* ArrayList基于动态数组实现，linkedList基于双向链表实现
* ArrayList支持随机访问，LinkedList不支持
* LinkedList在任意位置添加删除元素更快
> 顺序访问:链表在内存中不是按顺序存放的，而是通过指针连在一起，为了访问莫一元素，必须从链头开始顺着指针才能找到某一个元素<br>
> 随机访问：数组在内存中是按顺序存放的，可以通过下标直接定位到某一元素存放的位置。<br>
> 真数组：1.在内存中连续分配。2.数组所存在的内存空间为数组专用，避免了数据被覆盖的问题。3.数组内存放的类型是确定的，唯一的。

# 哈希表
## HashMap和HashTable的对比
* HashTable可以使用synchronized
* HashMap可以插入键为null的Entry
* HashMap的迭代器是fail-fast迭代器
* HashMap不能保证随着时间的推移Map中的元素次序是不变的
## 解决冲突
### 开放定址法
也称再散列法，当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。
Hi=（H（key）+di）% m   i=1，2，…，n
#### 线性探测再散列
di=1，2，3，…，m-1
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
#### 二次探测再散列
di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
#### 伪随机探测再散列
di=伪随机数序列。
### 再哈希法
这种方法是同时构造多个不同的哈希函数
这种方法不易产生聚集，但增加了计算时间。
### 链地址法
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。
hashmap采用拉链法